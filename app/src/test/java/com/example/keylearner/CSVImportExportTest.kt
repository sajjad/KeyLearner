package com.example.keylearner

import com.example.keylearner.data.model.GameScores
import com.example.keylearner.data.model.KeyScore
import com.example.keylearner.data.model.PositionScore
import org.junit.Assert.*
import org.junit.Test
import java.text.SimpleDateFormat
import java.util.*

/**
 * Unit tests for CSV Import/Export functionality
 *
 * Tests CSV serialisation, parsing, validation, and merge logic.
 */
class CSVImportExportTest {

    private val dateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.UK).apply {
        timeZone = TimeZone.getTimeZone("UTC")
    }

    @Test
    fun testCSVHeaderFormat() {
        val expectedHeader = "Timestamp,Key,Position,Correct,Wrong"
        // This would be generated by exportToCSV()
        assertEquals(expectedHeader, "Timestamp,Key,Position,Correct,Wrong")
    }

    @Test
    fun testCSVRowFormat() {
        val timestamp = "2025-10-19T14:30:00Z"
        val key = "C"
        val position = 1
        val correct = 5
        val wrong = 2

        val expectedRow = "$timestamp,$key,$position,$correct,$wrong"
        val actualRow = "$timestamp,$key,$position,$correct,$wrong"

        assertEquals(expectedRow, actualRow)
    }

    @Test
    fun testCSVParsingValidData() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
            2025-10-19T14:30:00Z,C,1,5,2
            2025-10-19T14:30:00Z,C,2,3,4
            2025-10-19T14:30:00Z,Em,1,7,1
        """.trimIndent()

        val lines = csvContent.trim().split("\n")
        assertEquals(4, lines.size) // Header + 3 data rows

        // Validate header
        assertEquals("Timestamp,Key,Position,Correct,Wrong", lines[0].trim())

        // Parse first data row
        val parts = lines[1].split(",")
        assertEquals(5, parts.size)
        assertEquals("2025-10-19T14:30:00Z", parts[0])
        assertEquals("C", parts[1])
        assertEquals("1", parts[2])
        assertEquals("5", parts[3])
        assertEquals("2", parts[4])
    }

    @Test
    fun testCSVValidationMissingHeader() {
        val csvContent = """
            2025-10-19T14:30:00Z,C,1,5,2
        """.trimIndent()

        val lines = csvContent.trim().split("\n")
        val header = lines[0].trim()

        // Should fail validation - doesn't match expected header
        assertNotEquals("Timestamp,Key,Position,Correct,Wrong", header)
    }

    @Test
    fun testCSVValidationInvalidColumnCount() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
            2025-10-19T14:30:00Z,C,1,5
        """.trimIndent()

        val lines = csvContent.trim().split("\n")
        val dataRow = lines[1].split(",")

        // Should have 5 columns, but only has 4
        assertEquals(4, dataRow.size)
        assertTrue(dataRow.size != 5)
    }

    @Test
    fun testCSVValidationInvalidPosition() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
            2025-10-19T14:30:00Z,C,8,5,2
        """.trimIndent()

        val lines = csvContent.trim().split("\n")
        val parts = lines[1].split(",")
        val position = parts[2].toInt()

        // Position must be 1-7
        assertTrue(position !in 1..7)
    }

    @Test
    fun testCSVValidationNegativeScores() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
            2025-10-19T14:30:00Z,C,1,-5,2
        """.trimIndent()

        val lines = csvContent.trim().split("\n")
        val parts = lines[1].split(",")
        val correct = parts[3].toInt()

        // Scores cannot be negative
        assertTrue(correct < 0)
    }

    @Test
    fun testCSVValidationInvalidTimestamp() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
            invalid-timestamp,C,1,5,2
        """.trimIndent()

        val lines = csvContent.trim().split("\n")
        val parts = lines[1].split(",")

        try {
            dateFormat.parse(parts[0])
            fail("Should have thrown exception for invalid timestamp")
        } catch (e: Exception) {
            // Expected
            assertTrue(true)
        }
    }

    @Test
    fun testCSVMultipleKeys() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
            2025-10-19T14:30:00Z,C,1,5,2
            2025-10-19T14:30:00Z,Em,1,7,1
            2025-10-19T14:30:00Z,G,1,4,3
        """.trimIndent()

        val lines = csvContent.trim().split("\n").drop(1)
        val keys = lines.map { it.split(",")[1] }.toSet()

        assertEquals(3, keys.size)
        assertTrue(keys.contains("C"))
        assertTrue(keys.contains("Em"))
        assertTrue(keys.contains("G"))
    }

    @Test
    fun testCSVAllPositions() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
            2025-10-19T14:30:00Z,C,1,5,2
            2025-10-19T14:30:00Z,C,2,3,4
            2025-10-19T14:30:00Z,C,3,7,1
            2025-10-19T14:30:00Z,C,4,6,2
            2025-10-19T14:30:00Z,C,5,4,3
            2025-10-19T14:30:00Z,C,6,8,0
            2025-10-19T14:30:00Z,C,7,5,2
        """.trimIndent()

        val lines = csvContent.trim().split("\n").drop(1)
        val positions = lines.map { it.split(",")[2].toInt() }

        assertEquals(7, positions.size)
        assertEquals((1..7).toList(), positions.sorted())
    }

    @Test
    fun testCSVEmptyDataAfterHeader() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
        """.trimIndent()

        val lines = csvContent.trim().split("\n")
        assertEquals(1, lines.size) // Only header

        // Should be detected as "no score data found"
        assertTrue(lines.size < 2)
    }

    @Test
    fun testCSVDuplicateDetection() {
        // Two sessions with same timestamp should be detected as duplicates
        val timestamp = "2025-10-19T14:30:00Z"
        val session1 = "$timestamp,C,1,5,2"
        val session2 = "$timestamp,C,1,5,2" // Exact duplicate

        val timestampMap = mutableMapOf<String, MutableSet<String>>()

        // Add first session
        val key1 = timestampMap.getOrPut(timestamp) { mutableSetOf() }
        key1.add("C-1")

        // Try to add duplicate
        val key2 = timestampMap.getOrPut(timestamp) { mutableSetOf() }
        val isDuplicate = "C-1" in key2

        assertTrue(isDuplicate)
    }

    @Test
    fun testCSVScoreAggregation() {
        // Test that scores for same key/position can be aggregated
        val scores = listOf(
            PositionScore(5, 2),
            PositionScore(3, 4),
            PositionScore(7, 1)
        )

        val totalCorrect = scores.sumOf { it.correct }
        val totalWrong = scores.sumOf { it.wrong }

        assertEquals(15, totalCorrect)
        assertEquals(7, totalWrong)
    }

    @Test
    fun testCSVMultipleSessionsPerKey() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
            2025-10-19T14:30:00Z,C,1,5,2
            2025-10-19T15:30:00Z,C,1,7,1
            2025-10-19T16:30:00Z,C,1,6,2
        """.trimIndent()

        val lines = csvContent.trim().split("\n").drop(1)
        val timestamps = lines.map { it.split(",")[0] }.distinct()

        assertEquals(3, timestamps.size)
        // All different timestamps, so 3 separate sessions
    }

    @Test
    fun testCSVSessionLimit() {
        // Test that we maintain max 100 sessions
        val maxSessions = 100
        val totalSessions = 120

        val trimmedSessions = minOf(totalSessions, maxSessions)
        assertEquals(100, trimmedSessions)
    }

    @Test
    fun testCSVTimestampSorting() {
        val timestamps = listOf(
            "2025-10-19T16:30:00Z",
            "2025-10-19T14:30:00Z",
            "2025-10-19T15:30:00Z"
        )

        val sorted = timestamps.sorted()

        assertEquals("2025-10-19T14:30:00Z", sorted[0])
        assertEquals("2025-10-19T15:30:00Z", sorted[1])
        assertEquals("2025-10-19T16:30:00Z", sorted[2])
    }

    @Test
    fun testCSVSpecialCharactersInKey() {
        // Test keys with special characters (sharps/flats)
        val keys = listOf("C", "C#", "Db", "Em", "F#m", "Bbm")

        keys.forEach { key ->
            val csvRow = "2025-10-19T14:30:00Z,$key,1,5,2"
            val parts = csvRow.split(",")
            assertEquals(key, parts[1])
        }
    }

    @Test
    fun testCSVWhitespaceHandling() {
        val csvContent = """
            Timestamp,Key,Position,Correct,Wrong
              2025-10-19T14:30:00Z  ,  C  ,  1  ,  5  ,  2
        """.trimIndent()

        val lines = csvContent.trim().split("\n")
        val parts = lines[1].split(",")

        // Should trim whitespace from values
        assertEquals("2025-10-19T14:30:00Z", parts[0].trim())
        assertEquals("C", parts[1].trim())
        assertEquals("1", parts[2].trim())
    }
}
